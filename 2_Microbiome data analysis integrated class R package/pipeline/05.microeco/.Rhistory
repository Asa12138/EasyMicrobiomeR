knitr::opts_chunk$set(
collapse = T, echo=T, comment="#>", message=F, warning=F,
fig.align="center", fig.width=5, fig.height=3, dpi=150)
# 基于CRAN安装R包
p_list = c("ggplot2", "BiocManager", "devtools","picante", "GUniFrac", "ggalluvial", "rgexf")
for(p in p_list){if (!requireNamespace(p)){install.packages(p)}
library(p, character.only = T, quietly = T, warn.conflicts = F)}
# 基于Bioconductor安装R包
if (!requireNamespace("ggtree", quietly = T))
BiocManager::install("ggtree")
# 基于github安装，检测没有则安装
library(devtools)
if(!requireNamespace("microeco", quietly = T))
install_github("ChiLiubio/microeco")
if(!requireNamespace("SpiecEasi", quietly = T))
install_github("zdk123/SpiecEasi")
install_github("zdk123/SpiecEasi")
library("SpiecEasi")
BiocManager::install("VGAM")
library("SpiecEasi")
BiocManager::install("huge")
library("SpiecEasi")
BiocManager::install("pulsar")
BiocManager::install("pulsar")
library("SpiecEasi")
library("SpiecEasi")
# 加载R包
library(microeco)
# 加载ggplot2绘图包并设置样式
library(ggplot2)
theme_set(theme_classic())
# 设置随机数据，使用结果可重复
set.seed(315)
# 设置输出图片尺寸(mm)
width = 89
height = 59
# 加载扩增子分析数据：元数据、OTU表、物种注释、进化树
metadata = read.table("../../data_microeco/metadata.txt", header=T, row.names=NULL, sep="\t", comment.char="")
rownames(metadata) = metadata$SampleID
otutab = read.table("../../data_microeco/otutab.txt", header=T, row.names=1, sep="\t", comment.char="")
taxonomy = read.table("../../data_microeco/taxonomy.txt", header=T, row.names=1, sep="\t", comment.char="")
library(phyloseq)
tree = read_tree("../../data_microeco/otus.tree")
env = read.table("../../data_microeco/env.txt", header=T, row.names=1, sep="\t", comment.char="")
# 特征表(OTU/ASV table)
otutab[1:5, 1:5]
# 物种7级注释
taxonomy[1:5, 1:3]
# 使用流程写法%<>%，类似于Linux中的"|"
library(magrittr)
taxonomy %<>% tidy_taxonomy
# 样本元数据
metadata[1:5, ]
# 生成本包数据格式
dataset = microtable$new(sample_table = metadata, otu_table = otutab, tax_table = taxonomy, phylo_tree = tree) #
dataset
# 生成本包数据格式
dataset = microtable$new(sample_table = metadata, otu_table = otutab, tax_table = taxonomy, phylo_tree = tree) #
# 交叉筛选
dataset$tidy_dataset()
dataset
# 按界筛选
dataset$tax_table %<>% base::subset(Kingdom == "Archaea" | Kingdom == "Bacteria")
print(dataset)
taxonomy %<>% tidy_taxonomy
# 物种7级注释
taxonomy[1:5, 1:3]
# 按界筛选
dataset$tax_table %<>% base::subset(Kingdom == "Archaea" | Kingdom == "k__Bacteria")
print(dataset)
# 按界筛选
dataset$tax_table %<>% base::subset(Kingdom == "k__Archaea" | Kingdom == "k__Bacteria")
print(dataset)
dataset$tax_table
microtable$new
# 生成本包数据格式
dataset = microtable$new(sample_table = metadata, otu_table = otutab, tax_table = taxonomy, phylo_tree = tree) #
# 交叉筛选
dataset$tidy_dataset()
# 按界筛选
dataset$tax_table %<>% base::subset(Kingdom == "k__Archaea" | Kingdom == "k__Bacteria")
print(dataset)
# 物种7级注释
taxonomy[1:5, 1:3]
# 过滤叶绿体和线粒体
dataset$filter_pollution(taxa = c("c__mitochondria", "c__chloroplast"))
# 物种7级注释
taxonomy[1:5, 1:4]
# 过滤叶绿体和线粒体
dataset$filter_pollution(taxa = c("o__mitochondria", "o__chloroplast"))
# 过滤叶绿体和线粒体
dataset$filter_pollution(taxa = c("c__mitochondria", "c__chloroplast"))
print(dataset)
# 过滤后物种注释与OTU表不对应，再交叉筛选
dataset$tidy_dataset()
print(dataset)
# 统计样本数据量范围
dataset$sample_sums() %>% range
dataset$sample_sums()
# 按各分类层级汇总
dataset$cal_abund()
dataset$cal_abund
class(dataset$taxa_abund)
# 保存层级表，界、门、纲、目、科、属和种共7个
dir.create("tax", recursive=T)
# 保存层级表，界、门、纲、目、科、属和种共7个
dir.create("tax", recursive=T)
dataset$save_abund(dirpath = "tax")
# 计算alpha多样性，并保存
dataset$cal_alphadiv(PD = T)
dir.create("alpha", recursive=T)
dataset$save_alphadiv(dirpath = "alpha")
# 计算beta多样性，并保存
dataset$cal_betadiv(unifrac = T)
dir.create("beta", recursive=T)
dataset$save_betadiv(dirpath = "beta")
trans_alpha$new
# 计算alpha多样性
t1 = trans_alpha$new(dataset = dataset, group = "Group")
t1$alpha_stat[1:5, ]
# KW组间统计
t1$cal_diff(method = "KW")
t1$res_alpha_diff[1:5, ]
# ANOVA统计
t1$cal_diff(method = "anova")
t1$res_alpha_diff
t1$plot_alpha(add_letter = T, measure = "Observed")
(p = t1$plot_alpha(pair_compare = T, measure = "Observed"))
t1$plot_alpha(add_letter = T, measure = "Observed")
plot_alpha
plot_alpha
# ANOVA统计
t1$cal_diff(method = "anova")
t1$res_alpha_diff
t1
t1$res_alpha_diff
# 按组合并样本
dataset1 = dataset$merge_samples(use_group = "Group")
# 生成维恩图，按多样性numratio/丰度seqratio
t1 = trans_venn$new(dataset1, ratio = "numratio")
# 数值是OTU各类，比例是相对丰度
t1$plot_venn()
# 保存图片
dir.create("venn", recursive=T)
pdf(file="venn/OTU_numratio.pdf", width=183/25.4, height=89/25.4, pointsize=8)
t1$plot_venn()
dev.off()
dev.off()
plot_venn()
plot_venn
t1$plot_venn()
trans_venn$new
t1
t1$plot_venn()
t1$plot_venn
# 计算beta多样性
t1 = trans_beta$new(dataset = dataset, group = "Group", measure = "bray", ordination = "PCoA")
# 可视化，按组着色、形状，添加椭圆
(p = t1$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_group_ellipse = T))
ggsave(paste0("beta/", "PCoA","_","bray",".pdf"), p, width = width*2, height = height*2, units = "mm")
trans_beta
trans_beta$new
# 可视化，按组着色、形状，添加椭圆
(p = t1$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_group_ellipse = T))
# 计算beta多样性
t1 = trans_beta$new(dataset = dataset, group = "Group", measure = "bray", ordination = "PCoA")
# 可视化，按组着色、形状，添加椭圆
(p = t1$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_group_ellipse = T))
# 计算beta多样性
t1 = trans_beta$new(dataset = dataset, group = "Group", measure = "bray")
# 可视化，按组着色、形状，添加椭圆
(p = t1$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_group_ellipse = T))
? trans_beta$new
# 计算组内距离
t1$cal_group_distance()
# 组间统计
(p = t1$plot_group_distance(distance_pair_stat = T))
ggsave(paste0("beta/", "Boxplot_distance","_","bray",".pdf"), p, width = width*2, height = height*2, units = "mm")
```{r, fig.width=7, fig.height=4}
# 绘制前10个门
t1 = trans_abund$new(dataset = dataset, taxrank = "Phylum", ntaxa = 10)
(p = t1$plot_bar(others_color = "grey70", facet = "Group", xtext_keep = F, legend_text_italic = F))
ggsave(paste0("tax/", "Phylum","_","Sample",".pdf"), p, width = width*2, height = height*2, units = "mm")
# 按组均值
t1 = trans_abund$new(dataset = dataset, taxrank = "Phylum", ntaxa = 10, groupmean = "Group")
(p = t1$plot_bar(others_color = "grey70", legend_text_italic = F))
ggsave(paste0("tax/", "Phylum","_","Group",".pdf"), p, width = width*2, height = height*2, units = "mm")
# 冲击图样式
t1 = trans_abund$new(dataset = dataset, taxrank = "Phylum", ntaxa = 8)
(p = t1$plot_bar(use_alluvium = T, clustering = T, xtext_type_hor = F, xtext_size = 6))
ggsave(paste0("tax/", "Phylum","_","alluvium",".pdf"), p, width = width*2, height = height*2, units = "mm")
t1 = trans_abund$new(dataset = dataset, taxrank = "Class", ntaxa = 15)
(p = t1$plot_box(group = "Group"))
ggsave(paste0("tax/", "Class","_","boxplot",".pdf"), p, width = width*3, height = height*3, units = "mm")
# 热图展示前40个属
t1 = trans_abund$new(dataset = dataset, taxrank = "Phylum", ntaxa = 30)
(p = t1$plot_heatmap(facet = "Group", xtext_keep = F, withmargin = F))
# 计算前6个门的均值
t1 = trans_abund$new(dataset = dataset, taxrank = "Phylum", ntaxa = 6, groupmean = "Group")
# 饼图按一行显示
(p = t1$plot_pie(facet_nrow = 1))
ggsave(paste0("tax/", "Phylum","_","pie",".pdf"), p, width = width*3, height = height*3, units = "mm")
# 在属水平使用metasata分析各组差异
t1 = trans_diff$new(dataset = dataset, method = "metastat", group = "Group", metastat_taxa_level = "Genus")
# 可视化第一组，前10个属
(p = t1$plot_metastat(use_number = 1:10, qvalue = 0.05, choose_group = 1))
dir.create("diff", recursive=T)
ggsave(paste0("diff/", "Genus","_","metastat",".pdf"), p, width = width*4, height = height*4, units = "mm")
# lefse分析各组差异
t1 = trans_diff$new(dataset = dataset, method = "lefse", group = "Group", alpha = 0.01, lefse_subgroup = NULL)
# t1$res_lefse是LEfSe结果
# t1$res_abund是丰度信息
(p = t1$plot_lefse_bar(LDA_score = 4))
ggsave(paste0("diff/", "lefse","_","Group",".pdf"), p, width = width*4, height = height*4, units = "mm")
t1$res_lefse[1:5, ]
# 显示前30差异，柱+标准差
(p = t1$plot_diff_abund(use_number = 1:30))
ggsave(paste0("diff/", "lefse","_","Group_errorbar",".pdf"), p, width = width*4, height = height*4, units = "mm")
# 绘制物种树
t1$plot_lefse_cladogram(use_taxa_num = 200, use_feature_num = 50, clade_label_level = 5)
# 随机森林：按分组找属水平标记
t1 = trans_diff$new(dataset = dataset, method = "rf", group = "Group", rf_taxa_level = "Genus")
# 展示前20的特征
t2 = t1$plot_diff_abund(use_number = 1:20, only_abund_plot = F)
# 拼图
(p = gridExtra::grid.arrange(t2$p1, t2$p2, ncol=2, nrow = 1, widths = c(2,2)))
# RDA分析增加环境因子
t1 = trans_env$new(dataset = dataset, add_data = env[, 1:7])
# 使用bray-curtis距离dbrda
t1$cal_rda(use_dbrda = T, use_measure = "bray")
# 调整箭头长度，控制数量
t1$trans_rda(adjust_arrow_length = T, max_perc_env = 10)
# 按组着色绘图
(p = t1$plot_rda(plot_color = "Group"))
# 使用属水平
t1$cal_rda(use_dbrda = F, taxa_level = "Genus")
# 控制属显示数量
t1$trans_rda(show_taxa = 10, adjust_arrow_length = T, max_perc_env = 1500, max_perc_tax = 3000, min_perc_env = 200, min_perc_tax = 300)
# t1$res_rda_trans is the transformed result for plotting
(p = t1$plot_rda(plot_color = "Group"))
# mantel检验
t1$cal_mantel(use_measure = "bray")
t1$res_mantel
t1 = trans_env$new(dataset = dataset, add_data = env[, 1:7])
t1$cal_cor(add_abund_table = dataset$alpha_diversity)
t1$plot_corr()
# SparCC方法，依赖SpiecEasi包，速度较慢
# library(devtools)
# install_github("zdk123/SpiecEasi")
t1 = trans_network$new(dataset = dataset, cal_cor = "SparCC", taxa_level = "OTU", filter_thres = 0.005, SparCC_simu_num = 100)
# 自动选择相关性阈值
# t1$cal_network(p_thres = 0.01, COR_optimization = T)
# 相关性阈值0.7
t1$cal_network(p_thres = 0.01, COR_cut = 0.6)
# 保存网络文件，依赖rgexf包
# BiocManager::install("rgexf")
dir.create("net", recursive=T)
t1$save_network(filepath = "net/gephi.gexf")
# 计算网络属性
t1$cal_network_attr()
t1$res_network_attr
head(t1$res_network_attr,n=3)
write.table(t1$res_network_attr, file=paste("net/attribution.txt",sep=""), quote = F, sep="\t", eol = "\n", na = "NA", dec = ".", row.names = T, col.names = T)
# # 按门分类绘图
(p = t1$plot_taxa_roles(use_type = 2))
# 模块中特征值
t1$cal_eigen()
head(t1$res_eigen,n=2)
write.table(t1$res_eigen, file=paste("net/res_eigen.txt",sep=""), quote = F, sep="\t", eol = "\n", na = "NA", dec = ".", row.names = T, col.names = T)
t2 = trans_func$new(dataset)
t2$cal_spe_func()
t2$res_spe_func[1:5, 1:2]
# 计算网络中每个OTU的功能
t2$cal_spe_func_perc(use_community = F, node_type_table = network_node_type)
# 绘图
(p = t2$plot_spe_func_perc(select_samples = paste0("M", 1:10)))
t2 = trans_func$new(dataset)
t2$cal_spe_func()
t2$res_spe_func[1:5, 1:2]
# 计算网络中每个OTU的功能
t2$cal_spe_func_perc(use_community = F, node_type_table = network_node_type)
# 绘图
(p = t2$plot_spe_func_perc(select_samples = paste0("M", 1:10)))
dir.create("faprotx", recursive=T)
ggsave(paste0("faprotx/", "network_node",".pdf"), p, width = width*2, height = height*2, units = "mm")
# 绘图
(p = t2$plot_spe_func_perc(select_samples = paste0("M", 1:10)))
# 查看功能 分组列表
t2$func_group_list
# 查看某一类
t2$show_prok_func("methanotrophy")
# 计算相对丰度
t2$cal_spe_func_perc(use_community = T)
# 计算功能与环境因子相关
t3 = trans_env$new(dataset = dataset, add_data = env[, 1:7])
t3$cal_cor(add_abund_table = t2$res_spe_func_perc, cor_method = "spearman")
# 绘图
p = t3$plot_corr(pheatmap = T)
t3$cal_cor(add_abund_table = t2$res_spe_func_perc, cor_method = "spearman")
# 绘图
p = t3$plot_corr(pheatmap = T)
ggsave(paste0("faprotx/", "env_pheatmap",".pdf"), p, width = width*2, height = height*2, units = "mm")
knitr::opts_chunk$set(echo = TRUE,
fig.width = 7,
fig.height = 5,
fig.align = "center",
warning = FALSE,
message = FALSE
)
library(animalcules)
library(SummarizedExperiment)
library(MultiAssayExperiment)
#--得到phyloserq对象并提取必要数据信息
library(ggClusterNet)
library(phyloseq)
data(ps)
otu = as.data.frame(t(vegan_otu(ps)))
head(otu)
tax = as.data.frame((vegan_tax(ps)))
head(tax)
map = sample_data(ps)
head(map)
#--首先构造SummarizedExperiment对象，比较简单，类似phyloseq对象
micro <- SummarizedExperiment(assays=list(counts=as.matrix(otu)),
colData=map,
rowData=tax)
# 将SummarizedExperiment对象封装成为ExperimentList
mlist <- ExperimentList()
mlist[[1]] = micro
names(mlist) = "MicrobeGenetics"# 注意必须命名，否则无法区分每个部分数据组
# 构造不同数据组之间的记录文件
gistmap <- data.frame(
primary = row.names(map),
colname = row.names(map),
stringsAsFactors = FALSE)
maplistowe <- list(MicrobeGenetics = gistmap)
sampMapowe <- listToMap(maplistowe)
# colData文件为分组文件，数据框即可，本案例只有一个微生物组数据，所以直接用map文件就可以了。
#-下面就直接构建了MultiAssayExperiment文件
mae <- MultiAssayExperiment(experiments = mlist, colData = map,
sampleMap = sampMapowe)
run_animalcules()
p <- filter_summary_pie_box(mae,
samples_discard = c("subject_2", "subject_4"),
filter_type = "By Metadata",
sample_condition = "Group")
p
ggsave(p,"cs.pdf")
pdf("./cs.pdf")
p <- filter_summary_pie_box(mae,
samples_discard = c("subject_2", "subject_4"),
filter_type = "By Metadata",
sample_condition = "Group")
p
dev.off()
p <- filter_summary_bar_density(mae,
samples_discard = c("subject_2", "subject_4"),
filter_type = "By Metadata",
sample_condition = "Group")
p
